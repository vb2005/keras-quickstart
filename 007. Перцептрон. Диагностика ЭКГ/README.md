# Экспертная система определения сердечно-сосудистых заболеваний на основе ЭКГ
*На базе открытого набора данных: https://archive.ics.uci.edu/ml/datasets/Arrhythmia*

Перед Вами набор данных, содержащий информацию о данных ЭКГ 452 пациентов. Помимо данных во всех отведениях, набор также содердит сведения о возрасте/поле/весе/росте пациента. В последнем столбце идет диагноз. Я предлагаю просто оценить вероятность того, что пациенту нужна консультация кардиолога (система предсказала наличие заболевания).

# Блок 1
## Подключение библиотек

``` python
# Для работы потребуются: Бибилотеки для работы с данными (Pandas, Numpy)
import numpy as np
import pandas as pd

# Библиотека Keras. Последовательная модель и 2 вида слоёв: полносвязный и активационный
from keras import Sequential
from keras.layers import *

# Построитель графиков. Для наглядности
from matplotlib import pyplot as plt
``` 

# Блок 2
## Загрузка и чтение данных
Скачайте файл по ссылке: https://raw.githubusercontent.com/vb2005/keras-quickstart/main/Datasets/Arrhythmia.csv
И разместите его в рабочем каталоге Python

``` python
# Читаем данные из CSV и делаем из них массив Numpy.
# Попробуем сделать это через Pandas
df = pd.read_csv('Arrhythmia.csv', sep=";",header=None)
data = df.to_numpy()
```

# Блок 3
## Разделение сырых данных на выборки
``` python
# Последний столбец - диагноз. 1 - если здоров, 2..18 - коды заболеваний.
# Нейронная сеть будет лишь выявлять: здоров пациент или не очень.
# Поэтому 1 меняем на 0, а всё остальное на 1.

for i in range(452):
  if data[i,276] <= 1:
    data[i,276] = 0
  else:
    data[i,276] = 1
```
``` python
# Разделение данных на вход и выход
X = data[:,:276]
Y = data[:,276]
```
# Блок 4
## Модель нейронной сети

Поле для творчества. Слои и функции активации на Ваш выбор. Каждая новая строка - новый скрытый слой внутри сети. В качестве аргумента указывается активационная функция для всех нейронов данного слоя и их количество. Попробуйте самостоятельно описать архитектуру, которая даст лучшие показатели, чем эта архитектура. Сравните результаты в группе

``` python
model = Sequential()

# Первый слой - 274 нейрона (по размеру входного вектора). Далее данные приводятся при помощи функции активации Sigmoid
model.add(Input(276))

# Второй слой и последующие задают глубину обучения и количество весовых коэфициентов.
# Далеко не всегда разумно бесконечно наращивать глубину сети. Итогда сеть и из 2х слоёв
# Справляется с указанной задачей
model.add(Dense(200,"sigmoid"))
model.add(Dense(200,"sigmoid"))

# Выходной слой с 1 значением. У нас это индикатор наличия или отсутсвия заболевания
model.add(Dense(1,"sigmoid"))
```

# Блок 5
## Сборка сети и запуск обучения
Выбираем оптимизатор и функцию потерь и запускаем обучение. Для того, чтобы оценить точность работы на разных архитектурах используем во всех экспериментах равное число эпох и одинаковые функции потерь и активации

``` python
model.compile("Adam","MSE", metrics = ["accuracy"])            # Сборка графа. Указание оптимизатора и функции потерь
history = model.fit(                   # Результат обучения сохраняется в переменную history
    X,Y,                               # Обучающая выборка
    batch_size=32,                     # Размер посылки
    epochs=50,                         # Число эпох. Используем 50.
    validation_split=0.2)              # Выборка для валидации
```

# Блок 6
## Визуализация результатов
``` python
# Визуализация графика
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Функция потерь')
plt.ylabel('Потери (меньше - лучше)')
plt.xlabel('Число эпох')
plt.legend(['Обучающая', 'Тестовая'], loc='upper left')
plt.show()
```
# Блок 7
## Ручная оценка точности работы
Получаем предсказнанные на основании нейронной сети значения. Здесь для оценки применяется исходный массив X, что неправильно (объясните, почему?). Вычисляется разница между предсказанным значением и истинным.
``` python
pred_Y = model.predict(X).ravel()

# Вычисляем сумму модулей поэлементной разницы двух массивови делим на количество примеров
difference = pow((pred_Y - Y),2).sum() / len(pred_Y)

# Получаем итоговую точность работы на указанных примерах. Больше - лучше
print('Точность работы:', (100-difference*100), '%')
```

# Контрольные вопросы

1. Что такое нейрон?
2. Что такое нейронная сеть?
3. Функции активации. Виды и графики
4. Выборки данных: обучающая, валидационная, тестовая
5. Настройка модели: функция потерь, количество эпох, алгоритм обучения (оптимизатор)
6. Анализ результатов обучения. Что описывает метрика loss, val_loss?
7. Что такое недообучение и переобучение? Продемонстрируйте эти состояния на графике функции потерь
